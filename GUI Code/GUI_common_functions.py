#########################################################################
# A collection of common functions used for GUIs                        #
# analysis scripts                                                      #
#                                                                       #
# Author: Trevor Stirling                                               #
# Date: Nov 16, 2023                                                    #
#########################################################################

import PySimpleGUI as psg
import pyvisa
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import numpy as np
import math
from datetime import date
import sys, os

minus_button = b'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'
plus_button = b'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'

def BluePSGButton(text, key='no_key'):
	if key == 'no_key':
		key = text
	rounded_blue_button = b'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/GMzLdsAAFTiaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzE0NSA3OS4xNjIzMTksIDIwMTgvMDIvMTUtMjA6Mjk6NDMgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBFbGVtZW50cyAxNy4wIChXaW5kb3dzKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAyMC0xMC0wM1QxMTowOTowOS0wNDowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMjAtMTAtMDNUMTE6MDk6MDktMDQ6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDIwLTEwLTAzVDExOjA5OjA5LTA0OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDowNDFhMDAwNy1lMGJlLTk4NGYtODNlMy01ZGQxZTk2NjI5ZWQ8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDo1YjgyOTQ2Mi0wNThhLTExZWItOTQ3ZC04N2E5Njc3OWZkYzU8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDoxMWMzOWY4MS0xM2VmLWIzNGMtYWNkMy0xZTVjMTI5OWNmMGM8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6MTFjMzlmODEtMTNlZi1iMzRjLWFjZDMtMWU1YzEyOTljZjBjPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDIwLTEwLTAzVDExOjA5OjA5LTA0OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgRWxlbWVudHMgMTcuMCAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjA0MWEwMDA3LWUwYmUtOTg0Zi04M2UzLTVkZDFlOTY2MjllZDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAyMC0xMC0wM1QxMTowOTowOS0wNDowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIEVsZW1lbnRzIDE3LjAgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxwaG90b3Nob3A6RG9jdW1lbnRBbmNlc3RvcnM+CiAgICAgICAgICAgIDxyZGY6QmFnPgogICAgICAgICAgICAgICA8cmRmOmxpPjAwMDE1N0JCNEVDNjZDODMyQ0VBN0Q0OTgxOEYyQkI3PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+MEQyMERDMEVCMTBDQkE5Njg5N0M2NzNCRjkwNDI5ODQ8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT4xRDk5RjMzMUY1RkMyOUU0ODU5MkI1OERENENCRkUzMzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPjI2QzMwRDNBRTREQjZERTFFN0Y2M0JCQUE4NjBGNEI0PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+MkFFRkE4NTk0ODJBRTMxMEYwOEYxNEVCQkU3MUEyNTU8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT4zNDBDQUZCNkZCMzIwRDRGREVEMjc0M0ExRjUwNUI2ODwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPjQ4NTVBMzI3NzUwOTIzODkwMzQ5NjIwRkU2NUYzNjkxPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+NjZBREMzOThERjcwMDQ1RDgxMkU4OUMwNDIzRkFGNTA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT42QjI5MkM4MDQyRTY1QTcxMkZGMTk4NTdEMjhGQTZCRTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPjczNzQ2N0JGQzU2QkFDNTk2Q0M4QkNEOUUzNjk2QUU1PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+NzNDMEVENEM3ODE0RTg4RjlBMjQ3NzRFRjdGMTBBODk8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT44MUU0QzY3QjQ5QkFCMzlDNkU5QzExRjQxNUNEMTgyRTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPkEzQ0M2RjFEQTFDMTFBMDZDOUExOTEyQURDRDBFRjQ3PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+QTQ3QkZCNkY5NkMxRjBGMjhDMTI5RENCQkZBODRGNkQ8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT5BNTlDQUU4ODNCMzU0RjgyMEQ3OTFEODJCREVGRjE2MDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPkFGREUyQkMyMzA1QkUyRTc2Q0RCNTdBNDAwNzM3MEQyPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+Q0Q4RTcxRkQ1REQ3RkM5MjcyNkZFREQ5NDRBREEyMTE8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT5GM0Y5OURGQjBFMzE5QzUwQzRGNEQ2NUZCM0U1QjU5MzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPkY4REE4QjZDRUM5MDI5OTgzMzUxQkEzQzUyQTVCNzREPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjMyMjNhYzg2LWVkZTYtMTFkOS1hZGRiLWNiMWQ2NjAxOWMxNzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2YjM0YmVlZi1mNDg2LTExZDktOWFiYy1mNmY3MDc0YjFkN2E8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT5hZG9iZTpkb2NpZDpwaG90b3Nob3A6NmNjNzJkZDQtYzEyMi0xMWRhLTllYTAtYjQxMDIxN2JjNjA0PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjc4ZTg3ZmZlLWY5NWEtMTFkYi1hZmE5LWY3OGRhN2FiODZmZjwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPmFkb2JlOmRvY2lkOnBob3Rvc2hvcDo5NWFkMzRlOC01MTQwLTExZGEtOGFmNi1iNjQ4NmE1YjIwYjI8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT5hZG9iZTpkb2NpZDpwaG90b3Nob3A6YmViNmY0N2UtMjIzNS0xMWRjLWE0NGUtZjZiOGI4MzA4MWQ1PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmU3ZmI1OGNhLTk2NDItMTFkZC04MWEyLWRkMTQxMDNmNDUxNTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnV1aWQ6MDFGMUEwRjYxMUVGMTFEQjg4MUVBNkJFMDVFMjc2RDE8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT51dWlkOjA2MDFFMzM5QkFGMkREMTE5QTlEOTEwOTg5NjI4QzVGPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+dXVpZDoxODkyOTc1OTlFNUREQzExOEQxOUJGODREMUU2QjZEQTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnV1aWQ6MTk1MDE1MDhFMkVGMTFERDhCRUNDQjZCNDU1MkJFQTc8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT51dWlkOjJBNTJBMDEwMENGNERDMTFBQTAzRUZBRjc4RDI5ODlDPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+dXVpZDozMEMyMzlCODJFM0JERDExQjY1MUMwNzNDODY5RDI3MzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnV1aWQ6MzUwMEIwQ0M2QzUwMTFEQ0E1OEE4MUNDRUFFQjk2N0Q8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT51dWlkOjRBMzhCMjREN0NCNkREMTE5ODk5OUZCM0IyMkVFNUNFPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+dXVpZDo1MDg1RkUxQzVDRjFEQzExODQ5OTlCMkQ0NzNCNDBDNTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnV1aWQ6NTY5OTMxQUNFRTgyREMxMTk4NkVFQTgzNjFGMTQ3MTE8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT51dWlkOjU3RDRENjNDMDUzN0UwMTFBNjM1RUJFMzgyMzBCODQxPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+dXVpZDo1RjgzOTA1RDExRUYxMURCODgxRUE2QkUwNUUyNzZEMTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnV1aWQ6NjI1OTE1RTFEMEYyREQxMUIyQUVGODg5ODVDQTU4Njg8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT51dWlkOjcwNkY4OEYyMzAzQkREMTFCNjUxQzA3M0M4NjlEMjczPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+dXVpZDo5MEFERjdENTM5OEExMURGODYxMTk0MzZBMTdDQjIyNzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnV1aWQ6QTFFMjhDNEM1NjI5REMxMTlDNzZCNzZDOEFBMDk4NzQ8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT51dWlkOkE5Rjg5MTI5M0IxQzExREFCNTVCQzI1REIzOTc4NjA2PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+dXVpZDpCNTdGQjJFRUM4MEJEQzExOURCQThEMjJDNkE3OUM0NzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnV1aWQ6QkQ1NkJGM0FGQzM4REIxMUEwNzhFRjBBNDMwOTAyRDU8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT51dWlkOkJFREZCQTY5MEM2OERCMTE5NEE0RkFCMjk1MERCMjQ1PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+dXVpZDpDQUQxM0U4ODMwM0JERDExQjY1MUMwNzNDODY5RDI3MzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnV1aWQ6RDlGRkY3NkJDMThBRTAxMTk3RTJFNkIyMDZFQUIzOTU8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT51dWlkOkU0NUNENDFBNzdEN0REMTE4NkRFREQ1OEI3N0JFMDkxPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+dXVpZDpGNkFBNkUxMThCNURFMTExOTE0MUJBNTI3OTk1MzhGMDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6MDE4MDExNzQwNzIwNjgxMTg3MUZFNEFENzFFRTI1QzA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjAxODAxMTc0MDcyMDY4MTE4NzFGRUVCNTZEMUU3NDNCPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDowMTgwMTE3NDA3MjA2ODExOEY2MkVCMkFERTQ2RDI3MzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6MDE4MDExNzQwNzIwNjgxMTkxMDlGQTI5N0E3QTU5MDQ8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjAxODAxMTc0MDcyMDY4MTE5MkIwQkFBOTA0REUwRjhEPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDowMTgwMTE3NDA3MjA2ODExOTdBNURBRjI1ODNBMEE0QjwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6MDE4MDExNzQwNzIwNjgxMUFCMDhFOEU4RUUzRjAyODk8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjAyODAxMTc0MDcyMDY4MTE4OEM2QTI5ODQ0M0YxMEFDPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDowMjgwMTE3NDA3MjA2ODExOTEwOUM2NUE3MDQwMTM0MDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6MEEwOEJDOTI2MUEyREYxMUJCQjVDMUZFMzRDNjY0OEM8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjFDOEU5N0FBOEI0QkRGMTE4OTQxQjEwMTZEQkYxRDE0PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDoxRjgzQ0M1NjM2RTFFMDExQjc1MzgyQTY2NTdEMjA4RDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6MzE5RTE0NkRCNDM3RTIxMThENjBEQkI0MTU3NjYyQkU8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjM2RThEMTc2QkM3QURGMTFBM0M4QzZFMjExRUE4QkJGPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDo0RDVFODcxRTE1MTFFMjExOTU1M0RENDcyOUEyMzZDRjwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6NTE0MDRGNDMzOTQ0RTIxMUEyMzlDMDRBRkQ0NDQ4MUU8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjUxNTQ2RkREMTMyMDY4MTE5MkIwQkFBOTA0REUwRjhEPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDo1NDU0NkZERDEzMjA2ODExOTJCMEJBQTkwNERFMEY4RDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6NjM4ODgwRTgwOTIwNjgxMTkyQjBCQUE5MDRERTBGOEQ8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjY0ODg4MEU4MDkyMDY4MTE5MkIwQkFBOTA0REUwRjhEPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDo2NERGNTM3NjM1RTFFMDExQjc1MzgyQTY2NTdEMjA4RDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6NjY4ODgwRTgwOTIwNjgxMTkyQjBCQUE5MDRERTBGOEQ8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjY3ODg4MEU4MDkyMDY4MTE5MkIwQkFBOTA0REUwRjhEPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDo2RUQ1RTlDRDZGQzRERjExQjc1QzlCRTFENUIxNkVBMzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6NzNGREFEODU3RUNCRTExMUI1MUVCRkE3RDIwMUNDNEI8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOjk2MkFGRDIxNjgzOUUyMTE4NzA1ODUzNjA1RUY2MEJBPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDpBMzQ3Q0E3MUNFRENFMTExOUJFN0Y0NzJGQzQyQzU4NTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6QTY1Q0FDMUZDOTM3RTIxMThENjBEQkI0MTU3NjYyQkU8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOkE5Q0NBNkFGRkI0M0UxMTE5RURCRjYzRTA1ODA0MzA0PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDpCMjQwMUYyQjk2MzhFMjExQTY2MkI0N0U5QjhENzE0RTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6QkIzNTY1RTgxNTIwNjgxMTkyQjBCQUE5MDRERTBGOEQ8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOkMyMzU2NUU4MTUyMDY4MTE5MkIwQkFBOTA0REUwRjhEPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDpDMzczQ0VDMDM2MjA2ODExOEY2MkQwRjcwMTBBQzAyRjwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6Q0I1NzY4QzhGQjNBRTIxMUFBNDNGMUNGRTNEMkUyNTM8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOkNGMEY3NzJFOUY5MkUwMTFCMDBBQjc4N0Y4ODIyQjQ2PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDpEMDczREU4OURFM0VFMjExQkM2QUZERjZBNEZEMTc1RjwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6RDQwNTRFQzExOTIwNjgxMTkyQjBCQUE5MDRERTBGOEQ8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOkRBQTQ4QUM0NzYzRkUyMTE4M0EyQkZEMTQ2NjBDQTJGPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDpFMEE0OEFDNDc2M0ZFMjExODNBMkJGRDE0NjYwQ0EyRjwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6Rjc1RDkxOEExMTIwNjgxMTkyQjA4QkVFMjlDNzVERDI8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT54bXAuZGlkOkY3N0YxMTc0MDcyMDY4MTE4MDgzRUI4M0M2MkJEN0MxPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+eG1wLmRpZDpGNzdGMTE3NDA3MjA2ODExOTEwOUY4RkUyNzcxOEQ1QTwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnhtcC5kaWQ6RkJDNEQyMDQwQTIwNjgxMTkxMDlDQzY0MkM0NEVDMEM8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6QmFnPgogICAgICAgICA8L3Bob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4KICAgICAgICAgPHBob3Rvc2hvcDpDb2xvck1vZGU+MzwvcGhvdG9zaG9wOkNvbG9yTW9kZT4KICAgICAgICAgPHBob3Rvc2hvcDpJQ0NQcm9maWxlPnNSR0IgSUVDNjE5NjYtMi4xPC9waG90b3Nob3A6SUNDUHJvZmlsZT4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MTA5PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjM4PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4BWge9AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAHGSURBVHja7Nu9ihNRHIbx5/xnJpOZaAKbXWIjwUULkTU2rqgoYqM2FnaWfqAXYGWpjbjVegFiue028aPbzgURFuxUtNMNYkSLOJsx59joPZzA+1zC++PMnOa4EAKA3Xq0ceLd59HaZDo746FARVHiqIos2V451Lv39P71HcC7EII9ePbq+Obr91sha3aSrIEz01qRFLxnVk+hrn5eXT188eHtKzsp0Hrzcfexa+7rNIoSS1JwTmtFoxbwsz/UVdp5+2m0BlwzoPfjtz+bFSWWZgKLLeewNCNrlown/jTQM6BbzVzLJakGitkuSZliJbBgQO6SBKcTFvmBczhLAHIDdOuYr3RNnEs1TSA0JTQlNKEpoSmhCU0JTQlNaEpoSmhKaEJTQlNCE5oSmhKa0JTQlNCEpuYIzbfLfKop4m9/0agBb8DeoN/98u9xoYq0EAIr/e5XYM+A73cuD4bt3GaaJt7aufm7lwZDYGzA6OjBxedPbp5/sbrcrZqpfnMxlafGyeXFav3GuZfH+ktDYORCCAYsAaeAC8ARoAXo7VMEX0VgAnwAtoBt4Jv7/1AeaAMHgAUgE1o0aDUwBnaBX4D/CwAA//8DAOgHcZ21310BAAAAAElFTkSuQmCC'
	return psg.Button(text, font=('Tahoma', 12), image_data=rounded_blue_button, button_color=('black', psg.theme_background_color()), mouseover_colors=('#303030', psg.theme_background_color()), border_width=0, key=key)

def connect_to_Piezo(port, channel, axis):
	import serial
	from GUI_Interfaces import Newport_Piezo_Interface
	if sys.platform == "win32":
		return Newport_Piezo_Interface.Newport_Piezo("", port, channel, axis)
	else:
		psg.popup("Piezo is not yet configured for MacOS!")
		return False

def connect_to_PM(channel):
	from GUI_Interfaces import Newport_PM_Interface
	if sys.platform == "win32":
		from ctypes import c_int,c_bool,byref,windll
		address = r'C:\Program Files\Newport\Newport USB Driver\Bin\usbdll.dll'
		num_devices = c_int()
		windll.LoadLibrary(address).newp_usb_open_devices(c_int(0xCEC7), c_bool(1), byref(num_devices))
		if num_devices.value != 0:
			print(" Connected to Newport Power Meter via USB")
			return Newport_PM_Interface.Newport_PM("", address, channel)
		psg.popup("Could not connect to Newport Power Meter.")
		return False
	else:
		possible_addresses = ['USB0::0x104D::0xCEC7::NI-VISA-340787200::RAW','USB0::0x104D::0xCEC7::NI-VISA-336592896::RAW','USB0::0x104D::0xCEC7::NI-VISA-339738624::RAW','USB0::0x104D::0xCEC7::NI-VISA-341835776::RAW'] #Required on mac only, specific to each computer
		rm = pyvisa.ResourceManager()
		USB_connection = rm.list_resources('?*')
		if (len(USB_connection) <1):
			psg.popup("No USB devices detected. You may need to restart the computer.")
			return False
		for address in possible_addresses:
			if address in USB_connection:
				print(" Connected to Power Meter at",address)
				return Newport_PM_Interface.Newport_PM(rm, address, channel)
		psg.popup("No device found at any of "+str(possible_addresses))
		return False

def connect_to_GPIB(device_name,parameters=[]):
	if device_name == 'LDC3908':
		num_params = 7 #Source_mode,Source_channel,protection_voltage,protection_current,waveform,pulse_delay,pulse_width
		if len(parameters)<num_params:
			psg.popup(device_name+" requires "+str(num_params)+" parameters")
			return False
		from GUI_Interfaces import LDC3900_Interface
		GPIB_address = 'GPIB0::2::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = LDC3900_Interface.LDC3900(rm, GPIB_address, parameters[1], parameters[0],8)
		device_type = 'Source'
	elif device_name == 'LDC3916':
		num_params = 7 #Source_mode,Source_channel,protection_voltage,protection_current,waveform,pulse_delay,pulse_width
		if len(parameters)<num_params:
			psg.popup(device_name+" requires "+str(num_params)+" parameters")
			return False
		from GUI_Interfaces import LDC3900_Interface
		GPIB_address = 'GPIB0::5::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = LDC3900_Interface.LDC3900(rm, GPIB_address, parameters[1], parameters[0],16)
		device_type = 'Source'
	elif device_name == 'SR830':
		from GUI_Interfaces import SR830_Interface
		GPIB_address = 'GPIB0::8::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = SR830_Interface.SR830(rm, GPIB_address)
		device_type = 'Amplifier'
	elif device_name == 'SWS15101':
		from GUI_Interfaces import SWS15101_Interface
		GPIB_address = 'GPIB0::10::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = SWS15101_Interface.SWS15101(rm, GPIB_address)
		device_type = 'Laser'
	elif device_name == 'K2604B':
		num_params = 7 #Source_mode,Source_channel,protection_voltage,protection_current,waveform,pulse_delay,pulse_width
		if len(parameters)<num_params:
			psg.popup(device_name+" requires "+str(num_params)+" parameters")
			return False
		from GUI_Interfaces import K2604B_Interface
		GPIB_address = 'GPIB0::16::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = K2604B_Interface.K2604B(rm, GPIB_address, parameters[1], parameters[0])
		device_type = 'Source'
	elif device_name == 'AQ6317B':
		from GUI_Interfaces import AQ6317B_Interface
		GPIB_address = 'GPIB0::22::INSTR' #SYSTEM > MY ADRS
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = AQ6317B_Interface.AQ6317B(rm, GPIB_address)
		device_type = 'Spectrum_anlyzer'
	elif device_name == 'AQ6374':
		from GUI_Interfaces import AQ6374_Interface
		GPIB_address = 'GPIB0::22::INSTR' #Should change this to be different from AQ6317B
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = AQ6374_Interface.AQ6374(rm, GPIB_address)
		device_type = 'Spectrum_anlyzer'
	elif device_name == 'E4407B':
		from GUI_Interfaces import E4407B_Interface
		GPIB_address = 'GPIB0::18::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = E4407B_Interface.E4407B(rm, GPIB_address)
		device_type = 'Spectrum_anlyzer'
	elif device_name == 'B2902A':
		num_params = 7 #Source_mode,Source_channel,protection_voltage,protection_current,waveform,pulse_delay,pulse_width
		if len(parameters)<num_params:
			psg.popup(device_name+" requires "+str(num_params)+" parameters")
			return False
		from GUI_Interfaces import B2902A_Interface
		GPIB_address = 'GPIB0::23::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = B2902A_Interface.B2902A(rm, GPIB_address, parameters[1], parameters[0])
		device_type = 'Source'
	elif device_name == 'A86146B':
		from GUI_Interfaces import A8614x_Interface
		GPIB_address = 'GPIB0::24::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = A8614x_Interface.A8614x(rm, GPIB_address)
		device_type = 'Spectrum_anlyzer'
	elif device_name == 'A86142A':
		from GUI_Interfaces import A8614x_Interface
		GPIB_address = 'GPIB0::20::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = A8614x_Interface.A8614x(rm, GPIB_address)
		device_type = 'Spectrum_anlyzer'
	elif device_name == 'K2520':
		num_params = 7 #Source_mode,Source_channel,protection_voltage,protection_current,waveform,pulse_delay,pulse_width
		if len(parameters)<num_params:
			psg.popup(device_name+" requires "+str(num_params)+" parameters")
			return False
		from GUI_Interfaces import K2520_Interface
		GPIB_address = 'GPIB0::25::INSTR'
		rm = check_GPIB_connection(device_name, GPIB_address)
		if not rm:
			return False
		device_inst = K2520_Interface.K2520(rm, GPIB_address, parameters[1], parameters[0])
		device_type = 'Source'
	elif device_name.lower() == 'off':
		return 'off'
	else:
		psg.popup(device_name+" is not set up for communication")
		return False
	if device_type == 'Source':
		if parameters[0] == 'Current':
			device_inst.set_voltage_protection(parameters[2])
		elif parameters[0] == 'Voltage':
			device_inst.set_current_protection(parameters[3])
		else:
			psg.popup(Source+" mode must be either Current or Voltage")
			return False
		if parameters[4].lower() == "pulsed":
			device_inst.set_waveform('PULSED', parameters[5], parameters[6])
		elif parameters[4].lower() == "dc":
			device_inst.set_waveform('DC')
		else:
			psg.popup("Type must be either pulsed or DC")
			return False
	return device_inst

def check_GPIB_connection(device,GPIB_address):
	rm = pyvisa.ResourceManager()
	GPIB_connection = rm.list_resources()
	if (len(GPIB_connection) <1):
		psg.popup("No GPIB devices detected. You may need to restart the computer.")
		return False
	if GPIB_address in GPIB_connection:
		print(" Connected to",device,"via",GPIB_address)
	else:
		psg.popup("No device found at "+GPIB_address+". Check that the "+device+" is configured to this address.")
		return False
	return rm

def check_or_make_directory(dir_path):
	if not os.path.isdir(dir_path):
		os.makedirs(dir_path)
		print(" Created new directory:", dir_path)

def get_file_locations_GUI(save_data, save_fig, characterization_directory, subfolder_name, device_name, folder_date=date.today().strftime("%Y_%m_%d")):
	csv_location = ''
	png_location = ''
	if save_data or save_fig:
		main_directory = os.path.join(characterization_directory,folder_date,subfolder_name)
		if save_data:
			data_directory = os.path.join(main_directory,'Data')
			check_or_make_directory(data_directory)
			device_name = get_unique_file_path_GUI(data_directory, device_name, '.csv')[1] #ensures unique name to avoid overwriting data
			csv_location = os.path.join(data_directory,device_name + '.csv')
		if save_fig:
			figure_directory = os.path.join(main_directory,'Figures')
			check_or_make_directory(figure_directory)
			device_name = get_unique_file_path_GUI(figure_directory, device_name, '.png')[1] #ensures unique name to avoid overwriting data
			png_location = os.path.join(figure_directory,device_name + '.png')
	return [csv_location, png_location, device_name]

def get_unique_file_path_GUI(directory, old_name, extension):
	file_path = os.path.join(directory,old_name+extension)
	if os.path.isfile(file_path):
		window = psg.Window("Rename",[[psg.Text(old_name+extension+" already taken")],[psg.Text("Enter a new name or overwrite:")],[psg.InputText(old_name,key='name')],[BluePSGButton('Overwrite'),psg.Push(),BluePSGButton('Use New Name'),BluePSGButton('Cancel')]])
		while True: 
			event, values = window.read()
			if event == psg.WIN_CLOSED or event == 'Cancel':
				window.close()
				return 'cancelled', '-NULL-'
			elif event == 'Use New Name':
				name = values['name']
				window.close()
				file_path, name = get_unique_file_path_GUI(directory, name, extension)
				return file_path, name
			elif event == 'Overwrite':
				window.close()
				return file_path, old_name
	else:
		return file_path, old_name

def enforce_number(window,values,event,decimal_allowed=True,negative_allowed=False):
	number_string = values[event]
	if len(number_string):
		if negative_allowed and number_string == '-':
				return
		for i in range(len(number_string)):
			delete = False
			if number_string[i] == '-':
				if i!=0 or not negative_allowed:
					delete = True
			elif number_string[i] == '.':
				if '.' in number_string[:i] or not decimal_allowed:
					delete = True
			elif number_string[i] not in ('0123456789'):
				delete = True
			if delete:
				number_string = number_string[:i]+number_string[i+1:]
				window[event].update(number_string)
				return

def enforce_max_min(window,values,event,max,min,default=0):
	value = values[event]
	if len(value) and value != '-':
		try:
			value = int(value)
			if value > max:
				window[event].update(max)
			elif value < min:
				window[event].update(min)
		except:
			window[event].update(default)

def plot_LIV(device_name, power, current, voltage, show_best_fit=True, show_best_fit_numbers=True, plot_current_density=False, current_area=1, power2=False):
	#If plotting current density, expects area to be [cm^-2]
	#Calculate figure values
	power = [(x - power[0])*1000 for x in power] #converts from [W] to [mW] and zeros background
	if power2:
		power2 = [(x - power2[0])*1000 for x in power2] #converts from [W] to [mW] and zeros background
	current = [x*1000 for x in current] #converts from [A] to [mA]
	#Curve fit to piecewise linear function
	if len(power)<4:
		#can not curve fit
		good_fit = False
		threshold_current = 0
		post_thresh_slope = 0
	else:
		peak = max(power[0],power[1],power[2],power[3])
		for increasing_ends in range(4,len(power)):
			if power[increasing_ends] > peak:
				peak = power[increasing_ends]
			elif power[increasing_ends] < peak-.05:
				break
		current_fit = current[0:increasing_ends]
		power_fit = power[0:increasing_ends]
		threshold_estimate = (min(current_fit)+max(current_fit))/2
		dark_power_estimate = 0 #[mW]
		pre_thresh_slope_estimate = 0.001 #[mW/mA/facet]
		post_thresh_slope_estimate = 0.05 #[mW/mA/facet]
		estimate = [threshold_estimate, dark_power_estimate, pre_thresh_slope_estimate, post_thresh_slope_estimate]
		params,cov = curve_fit(piecewise_linear, current_fit, power_fit, estimate)
		threshold_current = params[0] #[mA]
		pre_thresh_slope = params[2] #[mW/mA/facet]
		post_thresh_slope = params[3] #[mW/mA/facet]
		if cov[0][0]<0:
			sd = math.inf
		else:
			sd = cov[0][0]**0.5
		good_fit = False
		#Check if standard deviation on threshold current is within 1/10 of the value chosen - experimental, consider changing to a better test
		if sd < threshold_current/10 and post_thresh_slope>pre_thresh_slope*1.5:
			good_fit = True
	#Format figure
	fig, ax1 = plt.subplots()
	plt.title(str(device_name))
	plt_colour = 'tab:blue'
	ax1.set_ylabel('Voltage [V]', color=plt_colour)
	if plot_current_density:
		ax1.plot([i/current_area/1000/1000 for i in current], voltage, color=plt_colour)
	else:
		ax1.plot(current, voltage, color=plt_colour)
	ax1.tick_params(axis='y', labelcolor=plt_colour)
	ax2 = ax1.twinx()
	plt_colour = 'tab:red'
	plt_colour_2 = 'tab:purple'
	ax2.set_ylabel('Power [mW]', color=plt_colour)
	if good_fit and show_best_fit:
		if plot_current_density:
			ax2.plot([i/current_area/1000/1000 for i in current_fit], piecewise_linear(current_fit,*params),'--',color='black',label='_nolegend_')
		else:
			ax2.plot(current_fit, piecewise_linear(current_fit,*params),'--',color='black',label='_nolegend_')
	if plot_current_density:
		ax2.plot([i/current_area/1000/1000 for i in current], power, color=plt_colour)
		x_label_string = 'Current Density [kA/cm^2]'
		if power2:
			ax2.plot([i/current_area/1000/1000 for i in current], power2, color=plt_colour_2)
	else:
		ax2.plot(current, power, color=plt_colour)
		x_label_string = 'Current [mA]'
		if power2:
			ax2.plot(current, power2, color=plt_colour_2)
	if good_fit and show_best_fit_numbers:
		ax1.set_xlabel(x_label_string+'\n\nThreshold current = '+"{:.1f}".format(threshold_current)+' mA\nSlope efficiency = '+"{:.1f}".format(post_thresh_slope*1000)+' mW/A/facet')
	else:
		ax1.set_xlabel(x_label_string)
	ax2.tick_params(axis='y', labelcolor=plt_colour)
	plt.tight_layout()
	if power2:
		ax2.legend(['Right facet', 'Left facet'])
	return [fig, threshold_current, post_thresh_slope, good_fit]

def find_FW(x,y,width_y,middle_out=False):
	y = [i for i in y] #convert to list in case of numpy array
	y_max_index = y.index(max(y))
	if middle_out:
		i = len(y)-1
		for i in range(y_max_index+1,len(y)):
			if y[i]<=width_y:
				FW_end = x[i-1]
				break
		if i == len(y)-1:
			FW_end = x[-1]
		i = 0
		for i in range(y_max_index-1,-1,-1):
			if y[i]<=width_y:
				FW_start = x[i+1]
				break
		if i == 0:
			FW_start = x[0]
	else:
		i = len(y)-1
		for i in range(len(y)-1,y_max_index,-1):
			if y[i]>=width_y:
				FW_end = x[i]
				break
		if i == y_max_index+1:
			FW_end = x[-1]
		i = 0
		for i in range(y_max_index-1,-1,-1):
			if y[i]>=width_y:
				FW_start = x[i]
				break
		if i == 0:
			FW_start = x[0]
	FWHM = FW_end-FW_start
	return [FWHM,FW_start,FW_end]

def piecewise_linear(x, x0, b, m1, m2):
	condlist = [x < x0, x >= x0]
	funclist = [lambda x: m1*x + b, lambda x: m1*x + b + m2*(x-x0)]
	return np.piecewise(x, condlist, funclist)

def plot_spectrum(device_name, x_data, power, show_max=False, show_max_numbers=True, show_SMSR=False, peak_width=15, show_FWHM=False, x_is_freq=False):
	#Find peak power
	if x_is_freq:
		max_index = np.argmax(power[1:])+1
	else:
		max_index = np.argmax(power)
	max_x = x_data[max_index]
	max_power = power[max_index]
	#Find SMSR
	peaks = []
	peak_power = []
	peak_distance = int((peak_width-1)/2)
	for i in np.arange(1+peak_distance,len(power)-peak_distance,1):
		if (i < max_index-peak_distance or i > max_index+peak_distance) and power[i] == max(power[i-peak_distance:i+peak_distance]):
			peaks.append(i)
			peak_power.append(power[i])
	SM_index = peak_power.index(max(peak_power))
	SM_power = peak_power[SM_index]
	SM_x = x_data[peaks[SM_index]]
	SMSR = max_power-SM_power;
	#Format figure
	fig, ax = plt.subplots()
	plt.title(str(device_name))
	ax.plot(x_data, power)
	if show_SMSR:
		plt.annotate(text='', xy=(SM_x,SM_power), xytext=(SM_x,max_power), arrowprops=dict(arrowstyle='<->'))
		SMSR_text = plt.text(SM_x,SM_power+SMSR/2,' SMSR = '+str(round(SMSR,2))+' dB ')
		if (x_data[-1]+x_data[0])/2 < SM_x:
			plt.setp(SMSR_text,'horizontalalignment','right')
	HM = max(power)-10*math.log10(2)
	[FWHM,FW_start,FW_end] = find_FW(x_data,power,HM)
	if show_FWHM:
		FWHM_arrow_length = (x_data[-1]-x_data[0])/6
		plt.annotate(text='', xy=(max(FW_start-FWHM_arrow_length,x_data[0]),HM), xytext=(FW_start,HM), arrowprops=dict(arrowstyle='<-'))
		plt.annotate(text='', xy=(min(FW_end+FWHM_arrow_length,x_data[-1]),HM), xytext=(FW_end,HM), arrowprops=dict(arrowstyle='<-'))
		if (x_data[-1]+x_data[0])/2 < (FW_start+FW_end)/2:
			FHWM_text_x = FW_start
		else:
			FHWM_text_x = FW_end
		if x_is_freq:
			FWHM_text = plt.text(FHWM_text_x,HM+3,' FWHM = '+str(round(FWHM*1e3,2))+' MHz ')
		else:
			FWHM_text = plt.text(FHWM_text_x,HM+3,' FWHM = '+str(round(FWHM,2))+' nm ')
		if (x_data[-1]+x_data[0])/2 < (FW_start+FW_end)/2:
			plt.setp(FWHM_text,'horizontalalignment','right')
	if show_max:
		ax.plot(max_x, max_power, 'ok', markerfacecolor="None")
	if show_max_numbers:
		if x_is_freq:
			ax.set_xlabel('Frequency [GHz]\n\nMax Power ='+"{:.1f}".format(max_power)+' dBm at '+"{:.2f}".format(max_x)+' GHz')
		else:
			ax.set_xlabel('Wavelength [nm]\n\nMax Power ='+"{:.1f}".format(max_power)+' dBm at '+"{:.2f}".format(max_x)+' nm')
	else:
		if x_is_freq:
			ax.set_xlabel('Frequency [GHz]')
		else:
			ax.set_xlabel('Wavelength [nm]')
	ax.set_ylabel('Power [dBm]')
	plt.tight_layout()
	return [fig, max_x, max_power, SMSR, FWHM]

def SechSqr(x, offset, amplitude, center, width, suppress_overflow=True):
	if suppress_overflow:
		import warnings
		warnings.filterwarnings("ignore", message="overflow encountered in ")
	return offset+amplitude/(np.cosh((x-center)/width)**2)

def envelope_indices(s, trough_reduction_factor=1, peak_reduction_factor=1):
	#Finds the indices of every trough and peak, or every trough_reduction_factor troughs and peak_reduction_factor peaks.
	s = np.array(s)
	extrema = -np.diff(np.sign(np.diff(s)))
	trough_indices = (extrema < 0).nonzero()[0]+1
	trough_indices_reduced = trough_indices[[i+np.argmin(s[trough_indices[i:i+trough_reduction_factor]]) for i in range(0,len(trough_indices),trough_reduction_factor)]]
	peak_indices = (extrema > 0).nonzero()[0]+1
	peak_indices_reduced = peak_indices[[i+np.argmax(s[peak_indices[i:i+peak_reduction_factor]]) for i in range(0,len(peak_indices),peak_reduction_factor)]]
	return trough_indices_reduced,peak_indices_reduced

def plot_autocorrelator(device_name, time, intensity, envelope_reduction_factor=20, plot_fit=True, plot_envelope=False, plot_lower=False, x_axis_calibrated=True, normalize=True, cutoff_freq=200e12, fit_type='low_pass'):
	if normalize: #normalize to a peak of 8 for an interferometric autocorrelation
		intensity_max = max(intensity)
		intensity = [i*8/intensity_max for i in intensity]
	intensity = np.array(intensity) #[A.U.]
	time = np.array(time) #[fs]
	if fit_type == 'envelope':
		lower_envelope_index, upper_envelope_index = envelope_indices(intensity, envelope_reduction_factor, envelope_reduction_factor)
		#estimate upper envelope fitting parameters and fit
		upper_offset_estimate = np.mean(intensity[upper_envelope_index[0:5]])
		width_estimate = 200 #[fs]
		max_index = np.argmax(intensity)
		max_time = time[max_index]
		upper_params,_ = curve_fit(SechSqr,time[upper_envelope_index],intensity[upper_envelope_index], p0=[upper_offset_estimate, 1-upper_offset_estimate, max_time, width_estimate])
		upper_params[3] = abs(upper_params[3]) #ensure width is positive
		FWHM = upper_params[3]*1.7627 #[fs]
		if plot_lower:
			#estimate lower envelope fitting parameters and fit
			lower_offset_estimate = np.mean(intensity[lower_envelope_index[0:5]])
			min_index = np.argmin(intensity)
			min_time = time[min_index]
			lower_params,_ = curve_fit(SechSqr,time[lower_envelope_index],intensity[lower_envelope_index], p0=[lower_offset_estimate, 0-upper_offset_estimate, min_time, FWHM])
		#incease fitted curve resolution 
		time_mesh = np.linspace(time[0],time[-1],1000)
		#Format figure
		fig, ax1 = plt.subplots()
		plt.plot(time,intensity,color='0.8')
		# legend_string = ["Measured Data","Sech^2"]
		if x_axis_calibrated:
			x_axis_text = 'Time [fs]'
		else:
			x_axis_text = 'Number of data points [uncalibrated]'
		if plot_envelope:
			plt.plot(time[upper_envelope_index],intensity[upper_envelope_index],color='0.1',label='_nolegend_')
			if plot_lower:
				plt.plot(time[lower_envelope_index],intensity[lower_envelope_index],color='0.1',label='_nolegend_')
		if plot_fit:
			plt.plot(time_mesh,SechSqr(time_mesh,*upper_params))
			if x_axis_calibrated:
				x_axis_text += '\nAutocorrelator sech$^2$ FWHM '+"{:.1f}".format(FWHM)+' fs\nCorresponding pulse FWHM '+"{:.1f}".format(FWHM/1.54)+' fs'
			else:
				x_axis_text += '\nAutocorrelator sech$^2$ FWHM '+"{:.1f}".format(FWHM)+' data points\nCorresponding pulse FWHM '+"{:.1f}".format(FWHM/1.54)+' data points'
			if plot_lower:
				plt.plot(time_mesh,SechSqr(time_mesh,*lower_params))
				if x_axis_calibrated:
					x_axis_text += '\nLower autocorrelator sech$^2$ FWHM '+"{:.1f}".format(lower_params[3])+' fs\nCorresponding lower pulse FWHM '+"{:.1f}".format(lower_params[3]/1.54)+' fs'
				else:
					x_axis_text += '\nLower autocorrelator sech$^2$ FWHM '+"{:.1f}".format(lower_params[3])+' data points\nCorresponding lower pulse FWHM '+"{:.1f}".format(lower_params[3]/1.54)+' data points'
		plt.xlabel(x_axis_text)
		plt.ylabel('Intensity [A.U.]')
		plt.title(device_name)
	else:
		#Filter
		Intensity_freq = np.fft.rfft(intensity)
		f = np.fft.rfftfreq(len(time),(time[1]-time[0])*1e-15)
		Intensity_low_freq = [Intensity_freq[i] if f[i]<=cutoff_freq else 0 for i in range(len(Intensity_freq))]
		intensity_low = np.fft.irfft(Intensity_low_freq)
		#Fit
		max_index = np.argmax(intensity_low)
		max_time = time[max_index]
		offset_estimate = abs(Intensity_freq[0])/len(intensity)
		width_estimate = 100 #[fs]
		filtered_params,_ = curve_fit(SechSqr,time,intensity_low, p0=[offset_estimate, 4-offset_estimate, max_time, width_estimate])
		filtered_params[3] = abs(filtered_params[3]) #ensure width is positive
		FWHM = filtered_params[3]*1.7627 #[fs]
		#incease fitted curve resolution 
		time_mesh = np.linspace(time[0],time[-1],1000)
		#Format figure
		fig, ax1 = plt.subplots()
		plt.plot(time,intensity,color='0.8')
		if x_axis_calibrated:
			x_axis_text = 'Time [fs]'
		else:
			x_axis_text = 'Number of data points [uncalibrated]'
		if plot_fit:
			plt.plot(time_mesh,SechSqr(time_mesh,*filtered_params))
			if x_axis_calibrated:
				x_axis_text += '\nAutocorrelator sech$^2$ FWHM '+"{:.1f}".format(FWHM)+' fs\nCorresponding pulse FWHM '+"{:.1f}".format(FWHM/1.54)+' fs'
			else:
				x_axis_text += '\nAutocorrelator sech$^2$ FWHM '+"{:.1f}".format(FWHM)+' data points\nCorresponding pulse FWHM '+"{:.1f}".format(FWHM/1.54)+' data points'
		plt.xlabel(x_axis_text)
		plt.ylabel('Intensity [A.U.]')
		plt.title(device_name)
	return [fig,FWHM/1.54]